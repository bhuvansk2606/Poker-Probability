# -*- coding: utf-8 -*-
"""Poker Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U7F10-XI18vrYJBEVNGZtTsv6CnRvSCc
"""

import itertools
import matplotlib.pyplot as plt
from collections import Counter

#function to evaluate the strength of a poker hand (you need to implement this)
def evaluate_hand(hand):
    #sort the hand by rank
    sorted_hand = sorted(hand, key=lambda x: x[0])

    #check for flush
    is_flush = len(set(card[1] for card in sorted_hand)) == 1

    #check for straight
    is_straight = all(sorted_hand[i][0] == sorted_hand[i + 1][0] - 1 for i in range(len(sorted_hand) - 1))

    #check the occurrences of each rank
    rank_counts = Counter(card[0] for card in sorted_hand)

    #check for four of a kind
    four_of_a_kind = any(count == 4 for count in rank_counts.values())

    #check for full house
    full_house = any(count == 3 for count in rank_counts.values()) and any(count == 2 for count in rank_counts.values())

    #check for three of a kind
    three_of_a_kind = any(count == 3 for count in rank_counts.values())

    #check for two pairs
    two_pairs = sum(count == 2 for count in rank_counts.values()) == 2

    #check for one pair
    one_pair = any(count == 2 for count in rank_counts.values())

    #determine hand strength based on the identified patterns
    if is_straight and is_flush:
        return 8  # Straight Flush
    elif four_of_a_kind:
        return 7  # Four of a Kind
    elif full_house:
        return 6  # Full House
    elif is_flush:
        return 5  # Flush
    elif is_straight:
        return 4  # Straight
    elif three_of_a_kind:
        return 3  # Three of a Kind
    elif two_pairs:
        return 2  # Two Pairs
    elif one_pair:
        return 1  # One Pair

    return 0  # High Card


#function to calculate the probability of winning based on the remaining cards
def calculate_win_probability(flop, turn, river, player_hand):
    deck = list(itertools.product(range(2, 15), ['Hearts', 'Diamonds', 'Clubs', 'Spades']))

    remaining_cards = [card for card in deck if card not in flop + turn + river + player_hand]

    win_count = 0
    total_combinations = 0

    for additional_cards in itertools.combinations(remaining_cards, 2):
        opponent_hand = flop + turn + river + list(additional_cards)
        player_strength = evaluate_hand(player_hand)
        opponent_strength = evaluate_hand(opponent_hand)

        if player_strength > opponent_strength:
            win_count += 1

        total_combinations += 1

    return win_count / total_combinations

#function to visualize the probabilities
def visualize_probabilities(flop, turn, river, player_hand):
    probabilities = calculate_win_probability(flop, turn, river, player_hand)

    labels = ['Win', 'Lose']
    sizes = [probabilities, 1 - probabilities]

    plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
    plt.title('Win Probability')
    plt.show()

# Example usage
flop = [(10, 'Hearts'), (7, 'Spades'), (3, 'Diamonds')]
turn = [(4, 'Clubs')]
river = [(8, 'Hearts')]
player_hand = [(7, 'Diamonds'), (10, 'Clubs')]

visualize_probabilities(flop, turn, river, player_hand)

# Example usage
flop = [(10, 'Hearts'), (7, 'Spades'), (3, 'Diamonds')]
turn = [(4, 'Clubs')]
river = [(8, 'Hearts')]
player_hand = [(7, 'Diamonds'), (10, 'Clubs')]

# Check the individual strengths of player's hand and community cards
print("Player's Hand Strength:", evaluate_hand(player_hand))
print("Flop Strength:", evaluate_hand(flop))
print("Turn Strength:", evaluate_hand(turn))
print("River Strength:", evaluate_hand(river))